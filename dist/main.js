var n={d:(t,e)=>{for(var o in e)n.o(e,o)&&!n.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:e[o]})},o:(n,t)=>Object.prototype.hasOwnProperty.call(n,t)},t={};function e(){console.log("this is just a test function......")}function o(){let n,t;console.log("linkedList() called...");let e=0;function o(){return t}function i(){return e}function r(e){return 0===i()&&(n=e,t=e,!0)}function c(e){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:n,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,u=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"",l=!1;return l=function(n,t,e,o){let{condition1:i,condition2:r}=n,c=!1;switch(t){case"at":case"pop":case"toString":case"insertAt":case"removeAt":r=e;break;case"contains":case"find":r=o}return c=i===r,c}(e,o,r,i.value),!0===l?"find"===o?r:"toString"===o?`${u}( ${i.value} ) ->  null`:i:i===t?i:(u=u.concat(`( ${i.value} )`,"->"),i=i.next,c(e,o,i,r+1,u))}function u(n){const i=a(n);return r(i),o().next=i,t=i,e++,i}function l(t){const o=a(t,n);return r(o),n=o,e++,o}function s(n){if(n+1>e)throw new Error("Invalid Index")}function a(){return{value:arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,next:arguments.length>1&&void 0!==arguments[1]?arguments[1]:null}}return{append:u,prepend:l,getHead:function(){return n},getSize:i,getTail:o,at:function(n){return s(n),c({condition1:n},"at")},pop:function(){try{if(e<=0)throw new Error("Cannot pop, size is 0");const n={...t};t.value=null;const o=c({condition1:e-2},"pop");return o.next=null,t=o,e-=1,n}catch(n){console.error(n)}},contains:function(n){return c({condition1:n},"contains").value===n},find:function(n){const t=c({condition1:n},"find");return Number.isInteger(t)?t:void 0},toString:function(){return c({condition1:e-1},"toString")},insertAt:function(n,t){try{if(s(t),0===t)return void l(n);if(t===e-1)return void u(n);const o=c({condition1:t},"insertAt"),i=a(n,o.next);return o.next=i,e+=1,i}catch(n){console.error(n)}},removeAt:function(n){try{if(s(n),0===n)return void aList.pop;const o=c({condition1:n-1},"removeAt"),i={...o.next};return o.next=o.next.next,n===e-1&&(t=o,console.log("NEW tail:",t)),e-=1,i}catch(n){console.error(n)}},node:a}}n.d(t,{P:()=>e,s:()=>o}),console.log("Linked List package loaded - test!!!");var i=t.s,r=t.P;export{i as linkedList,r as testFunc};
//# sourceMappingURL=main.js.map