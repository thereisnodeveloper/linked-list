{"version":3,"file":"main.js","mappings":"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","sources":["webpack://LinkedListLibrary/webpack/bootstrap","webpack://LinkedListLibrary/webpack/runtime/define property getters","webpack://LinkedListLibrary/webpack/runtime/hasOwnProperty shorthand","webpack://LinkedListLibrary/webpack/runtime/make namespace object","webpack://LinkedListLibrary/./src/index.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// import './reset.css';\n// import './style.css';\n\nconsole.log('Linked List package loaded - test!!!');\n// eslint-disable-next-line no-unused-vars\n\n// use Factory functions instead of clsasses\nfunction testFunc() {\n  console.log('test function......');\n}\n\nfunction linkedList() {\n  // export default function linkedList() {\n  let head;\n  let tail;\n  let size = 0;\n\n  function getTail() {\n    // MAYBE: I could traverse instead of storing tail in memory\n    return tail;\n  }\n\n  function getSize() {\n    return size;\n  }\n\n  function getHead() {\n    return head;\n  }\n\n  function checkIfSizeIs1(newNodeReference) {\n    if (getSize() === 0) {\n      head = newNodeReference;\n      tail = newNodeReference;\n      return true;\n    }\n    return false;\n  }\n\n  function traverse(\n    conditionObject,\n    mode = null,\n    currentNode = head,\n    currentIndex = 0,\n    resultString = ''\n  ) {\n    // TODO: calculate big O for time & space\n    // MAYBE: use loop instead\n\n    let stopConditionMet = false;\n    const currentValue = currentNode.value;\n\n    stopConditionMet = evaluateCondition(conditionObject, mode, currentIndex, currentValue);\n\n    // BASE CASE\n    if (stopConditionMet === true) {\n      if (mode === 'find') {\n        return currentIndex;\n      }\n      if (mode === 'toString') {\n        return `${resultString}( ${currentNode.value} ) -> ` + ' null';\n        // return resultString  + ' null';\n      }\n      return currentNode;\n    }\n    if (currentNode === tail) return currentNode;\n\n    // RECURSIVE CASE\n\n    resultString = resultString.concat(`( ${currentNode.value} )`, '->');\n    currentNode = currentNode.next;\n\n    return traverse(conditionObject, mode, currentNode, currentIndex + 1, resultString);\n  }\n\n  function evaluateCondition(conditionObject, mode, currentIndex, currentValue) {\n    // MAYBE: instead of using mode, assign \"this\" to static variable (which poiints to the caller function)\n    let { condition1, condition2 } = conditionObject;\n    let meetsCondition = false;\n    switch (mode) {\n      case 'at':\n      case 'pop':\n      case 'toString':\n      case 'insertAt':\n      case 'removeAt': {\n        condition2 = currentIndex;\n        break;\n      }\n      case 'contains':\n      case 'find': {\n        condition2 = currentValue;\n        break;\n      }\n\n      default:\n    }\n    meetsCondition = condition1 === condition2;\n\n    return meetsCondition;\n  }\n\n  function at(targetIndex) {  \n      isIndexValid(targetIndex);\n      const result = traverse({ condition1: targetIndex }, 'at');\n      return result;\n  }\n  function pop() {\n    try {\n      if (size <= 0) throw new Error('Cannot pop, size is 0');\n      const last = { ...tail };\n\n      tail.value = null;\n      const secondToLast = traverse({ condition1: size - 2 }, 'pop'); // find 2nd to the last element\n      secondToLast.next = null;\n      // set new tail value\n      tail = secondToLast;\n      size -= 1;\n\n      return last;\n    } catch (error) {\n      console.error(error);\n    }\n  }\n  function contains(value) {\n    const currentNode = traverse({ condition1: value }, 'contains');\n\n    return currentNode.value === value;\n  }\n\n  function find(value) {\n    const index = traverse({ condition1: value }, 'find');\n    return Number.isInteger(index) ? index : undefined; // traverse will return currentNode (tail) if nothing is found. If found, it will return an index,\n  }\n\n  function toString() {\n    return traverse({ condition1: size - 1 }, 'toString');\n  }\n  function append(value) {\n    const newNodeReference = node(value);\n\n    checkIfSizeIs1(newNodeReference);\n\n    getTail().next = newNodeReference;\n\n    tail = newNodeReference;\n    size++;\n\n    return newNodeReference;\n  }\n\n  function prepend(value) {\n    const newNodeReference = node(value, head);\n\n    checkIfSizeIs1(newNodeReference);\n\n    head = newNodeReference;\n    size++;\n    return newNodeReference;\n  }\n\n  function insertAt(value, index) {\n    try {\n      isIndexValid(index);\n\n      if (index === 0) {\n        prepend(value);\n        return;\n      }\n      if (index === size - 1) {\n        append(value);\n        return;\n      }\n\n      const insertionPoint = traverse({ condition1: index }, 'insertAt');\n      const newNode = node(value, insertionPoint.next);\n      insertionPoint.next = newNode;\n      size += 1;\n      return newNode;\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  function removeAt(index) {\n    try {\n      isIndexValid(index);\n      if (index === 0) {\n        aList.pop;\n        return;\n      }\n\n      const nodeBeforeTarget = traverse({ condition1: index - 1 }, 'removeAt');\n      const removalTarget = { ...nodeBeforeTarget.next };\n      nodeBeforeTarget.next = nodeBeforeTarget.next.next;\n      if (index === size - 1) {\n        tail = nodeBeforeTarget;\n        console.log('NEW tail:', tail);\n      }\n      size -= 1;\n      return removalTarget;\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  function isIndexValid(targetIndex) {\n    if (targetIndex + 1 > size) {\n      throw new Error('Invalid Index');\n    }\n  }\n\n  // MAYBE: use undefined instead of null\n  function node(value = null, next = null) {\n    return { value, next };\n  }\n\n  return {\n    append,\n    prepend,\n    getHead,\n    getSize,\n    getTail,\n    at,\n    pop,\n    contains,\n    find,\n    toString,\n    insertAt,\n    removeAt,\n    node,\n  };\n}\n\n// const aList = linkedList();\n// aList.append(2);\n// aList.append(5);\n// aList.append(4);\n// aList.prepend(10);\n// aList.prepend(7);\n// aList.prepend(8);\n\n// const at = aList.at(4);\n\n// const contains = aList.contains(8);\n// const find = aList.find(1000);\n\n// const toString = aList.toString();\n// console.log('toString:', toString);\n\n// const [head, tail, size] = [aList.getHead(), aList.getTail(), aList.getSize()];\n// console.log('head:', head);\n// console.log('tail:', tail);\n// console.log('size:', size);\n\nexport { testFunc, linkedList };\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","testFunc","console","log","linkedList","head","tail","size","getTail","getSize","checkIfSizeIs1","newNodeReference","traverse","conditionObject","mode","arguments","length","undefined","currentNode","currentIndex","resultString","stopConditionMet","currentValue","condition1","condition2","meetsCondition","evaluateCondition","concat","next","append","node","prepend","isIndexValid","targetIndex","Error","getHead","at","pop","last","secondToLast","error","contains","find","index","Number","isInteger","toString","insertAt","insertionPoint","newNode","removeAt","aList","nodeBeforeTarget","removalTarget"],"sourceRoot":""}