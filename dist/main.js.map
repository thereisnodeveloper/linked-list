{"version":3,"file":"main.js","mappings":"AACA,IAAIA,EAAsB,CCA1BA,EAAwB,CAACC,EAASC,KACjC,IAAI,IAAIC,KAAOD,EACXF,EAAoBI,EAAEF,EAAYC,KAASH,EAAoBI,EAAEH,EAASE,IAC5EE,OAAOC,eAAeL,EAASE,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,IAE1E,ECNDH,EAAwB,CAACS,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,I,KCOlF,SAASI,IACPC,QAAQC,IAAI,qCACd,CAEA,SAASC,IAGP,IAAIC,EACAC,EAHJJ,QAAQC,IAAI,0BAIZ,IAAII,EAAO,EAEX,SAASC,IAEP,OAAOF,CACT,CAEA,SAASG,IACP,OAAOF,CACT,CAMA,SAASG,EAAeC,GACtB,OAAkB,IAAdF,MACFJ,EAAOM,EACPL,EAAOK,GACA,EAGX,CAEA,SAASC,EACPC,GAKA,IAJAC,EAAIC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,KACPG,EAAWH,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAGV,EACdc,EAAYJ,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,EACfK,EAAYL,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,GAKXM,GAAmB,EAMvB,OAHAA,EAuBF,SAA2BR,EAAiBC,EAAMK,EAAcG,GAE9D,IAAI,WAAEC,EAAU,WAAEC,GAAeX,EAC7BY,GAAiB,EACrB,OAAQX,GACN,IAAK,KACL,IAAK,MACL,IAAK,WACL,IAAK,WACL,IAAK,WACHU,EAAaL,EACb,MAEF,IAAK,WACL,IAAK,OACHK,EAAaF,EAQjB,OAFAG,EAAiBF,IAAeC,EAEzBC,CACT,CA/CqBC,CAAkBb,EAAiBC,EAAMK,EAFvCD,EAAYS,QAKR,IAArBN,EACW,SAATP,EACKK,EAEI,aAATL,EACK,GAAGM,MAAiBF,EAAYS,mBAGlCT,EAELA,IAAgBZ,EAAaY,GAIjCE,EAAeA,EAAaQ,OAAO,KAAKV,EAAYS,UAAW,MAC/DT,EAAcA,EAAYW,KAEnBjB,EAASC,EAAiBC,EAAMI,EAAaC,EAAe,EAAGC,GACxE,CAgEA,SAASU,EAAOH,GACd,MAAMhB,EAAmBoB,EAAKJ,GAS9B,OAPAjB,EAAeC,GAEfH,IAAUqB,KAAOlB,EAEjBL,EAAOK,EACPJ,IAEOI,CACT,CAEA,SAASqB,EAAQL,GACf,MAAMhB,EAAmBoB,EAAKJ,EAAOtB,GAMrC,OAJAK,EAAeC,GAEfN,EAAOM,EACPJ,IACOI,CACT,CA+CA,SAASsB,EAAaC,GACpB,GAAIA,EAAc,EAAI3B,EACpB,MAAM,IAAI4B,MAAM,gBAEpB,CAGA,SAASJ,IACP,MAAO,CAAEJ,MADQZ,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,KACJc,KADcd,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,KAEnC,CAEA,MAAO,CACLe,SACAE,UACAI,QAjMF,WACE,OAAO/B,CACT,EAgMEI,UACAD,UACA6B,GAzHF,SAAYH,GAGR,OAFAD,EAAaC,GACEtB,EAAS,CAAEW,WAAYW,GAAe,KAEzD,EAsHEI,IArHF,WACE,IACE,GAAI/B,GAAQ,EAAG,MAAM,IAAI4B,MAAM,yBAC/B,MAAMI,EAAO,IAAKjC,GAElBA,EAAKqB,MAAQ,KACb,MAAMa,EAAe5B,EAAS,CAAEW,WAAYhB,EAAO,GAAK,OAMxD,OALAiC,EAAaX,KAAO,KAEpBvB,EAAOkC,EACPjC,GAAQ,EAEDgC,CACT,CAAE,MAAOE,GACPvC,QAAQuC,MAAMA,EAChB,CACF,EAsGEC,SArGF,SAAkBf,GAGhB,OAFoBf,EAAS,CAAEW,WAAYI,GAAS,YAEjCA,QAAUA,CAC/B,EAkGEgB,KAhGF,SAAchB,GACZ,MAAMiB,EAAQhC,EAAS,CAAEW,WAAYI,GAAS,QAC9C,OAAOkB,OAAOC,UAAUF,GAASA,OAAQ3B,CAC3C,EA8FE8B,SA5FF,WACE,OAAOnC,EAAS,CAAEW,WAAYhB,EAAO,GAAK,WAC5C,EA2FEyC,SAnEF,SAAkBrB,EAAOiB,GACvB,IAGE,GAFAX,EAAaW,GAEC,IAAVA,EAEF,YADAZ,EAAQL,GAGV,GAAIiB,IAAUrC,EAAO,EAEnB,YADAuB,EAAOH,GAIT,MAAMsB,EAAiBrC,EAAS,CAAEW,WAAYqB,GAAS,YACjDM,EAAUnB,EAAKJ,EAAOsB,EAAepB,MAG3C,OAFAoB,EAAepB,KAAOqB,EACtB3C,GAAQ,EACD2C,CACT,CAAE,MAAOT,GACPvC,QAAQuC,MAAMA,EAChB,CACF,EA+CEU,SA7CF,SAAkBP,GAChB,IAEE,GADAX,EAAaW,GACC,IAAVA,EAEF,YADAQ,MAAMd,IAIR,MAAMe,EAAmBzC,EAAS,CAAEW,WAAYqB,EAAQ,GAAK,YACvDU,EAAgB,IAAKD,EAAiBxB,MAO5C,OANAwB,EAAiBxB,KAAOwB,EAAiBxB,KAAKA,KAC1Ce,IAAUrC,EAAO,IACnBD,EAAO+C,EACPnD,QAAQC,IAAI,YAAaG,IAE3BC,GAAQ,EACD+C,CACT,CAAE,MAAOb,GACPvC,QAAQuC,MAAMA,EAChB,CACF,EA0BEV,OAEJ,C,yBArOA7B,QAAQC,IAAI,wC","sources":["webpack://@thereisnodeveloper/linked-list/webpack/bootstrap","webpack://@thereisnodeveloper/linked-list/webpack/runtime/define property getters","webpack://@thereisnodeveloper/linked-list/webpack/runtime/hasOwnProperty shorthand","webpack://@thereisnodeveloper/linked-list/./src/index.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// import './reset.css';\n// import './style.css';\n\nconsole.log('Linked List package loaded - test!!!');\n// eslint-disable-next-line no-unused-vars\n\n// use Factory functions instead of clsasses\nfunction testFunc() {\n  console.log('this is just a test function......');\n}\n\nfunction linkedList() {\n  console.log('linkedList() called...')\n  // export default function linkedList() {\n  let head;\n  let tail;\n  let size = 0;\n\n  function getTail() {\n    // MAYBE: I could traverse instead of storing tail in memory\n    return tail;\n  }\n\n  function getSize() {\n    return size;\n  }\n\n  function getHead() {\n    return head;\n  }\n\n  function checkIfSizeIs1(newNodeReference) {\n    if (getSize() === 0) {\n      head = newNodeReference;\n      tail = newNodeReference;\n      return true;\n    }\n    return false;\n  }\n\n  function traverse(\n    conditionObject,\n    mode = null,\n    currentNode = head,\n    currentIndex = 0,\n    resultString = ''\n  ) {\n    // TODO: calculate big O for time & space\n    // MAYBE: use loop instead\n\n    let stopConditionMet = false;\n    const currentValue = currentNode.value;\n\n    stopConditionMet = evaluateCondition(conditionObject, mode, currentIndex, currentValue);\n\n    // BASE CASE\n    if (stopConditionMet === true) {\n      if (mode === 'find') {\n        return currentIndex;\n      }\n      if (mode === 'toString') {\n        return `${resultString}( ${currentNode.value} ) -> ` + ' null';\n        // return resultString  + ' null';\n      }\n      return currentNode;\n    }\n    if (currentNode === tail) return currentNode;\n\n    // RECURSIVE CASE\n\n    resultString = resultString.concat(`( ${currentNode.value} )`, '->');\n    currentNode = currentNode.next;\n\n    return traverse(conditionObject, mode, currentNode, currentIndex + 1, resultString);\n  }\n\n  function evaluateCondition(conditionObject, mode, currentIndex, currentValue) {\n    // MAYBE: instead of using mode, assign \"this\" to static variable (which poiints to the caller function)\n    let { condition1, condition2 } = conditionObject;\n    let meetsCondition = false;\n    switch (mode) {\n      case 'at':\n      case 'pop':\n      case 'toString':\n      case 'insertAt':\n      case 'removeAt': {\n        condition2 = currentIndex;\n        break;\n      }\n      case 'contains':\n      case 'find': {\n        condition2 = currentValue;\n        break;\n      }\n\n      default:\n    }\n    meetsCondition = condition1 === condition2;\n\n    return meetsCondition;\n  }\n\n  function at(targetIndex) {  \n      isIndexValid(targetIndex);\n      const result = traverse({ condition1: targetIndex }, 'at');\n      return result;\n  }\n  function pop() {\n    try {\n      if (size <= 0) throw new Error('Cannot pop, size is 0');\n      const last = { ...tail };\n\n      tail.value = null;\n      const secondToLast = traverse({ condition1: size - 2 }, 'pop'); // find 2nd to the last element\n      secondToLast.next = null;\n      // set new tail value\n      tail = secondToLast;\n      size -= 1;\n\n      return last;\n    } catch (error) {\n      console.error(error);\n    }\n  }\n  function contains(value) {\n    const currentNode = traverse({ condition1: value }, 'contains');\n\n    return currentNode.value === value;\n  }\n\n  function find(value) {\n    const index = traverse({ condition1: value }, 'find');\n    return Number.isInteger(index) ? index : undefined; // traverse will return currentNode (tail) if nothing is found. If found, it will return an index,\n  }\n\n  function toString() {\n    return traverse({ condition1: size - 1 }, 'toString');\n  }\n  function append(value) {\n    const newNodeReference = node(value);\n\n    checkIfSizeIs1(newNodeReference);\n\n    getTail().next = newNodeReference;\n\n    tail = newNodeReference;\n    size++;\n\n    return newNodeReference;\n  }\n\n  function prepend(value) {\n    const newNodeReference = node(value, head);\n\n    checkIfSizeIs1(newNodeReference);\n\n    head = newNodeReference;\n    size++;\n    return newNodeReference;\n  }\n\n  function insertAt(value, index) {\n    try {\n      isIndexValid(index);\n\n      if (index === 0) {\n        prepend(value);\n        return;\n      }\n      if (index === size - 1) {\n        append(value);\n        return;\n      }\n\n      const insertionPoint = traverse({ condition1: index }, 'insertAt');\n      const newNode = node(value, insertionPoint.next);\n      insertionPoint.next = newNode;\n      size += 1;\n      return newNode;\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  function removeAt(index) {\n    try {\n      isIndexValid(index);\n      if (index === 0) {\n        aList.pop;\n        return;\n      }\n\n      const nodeBeforeTarget = traverse({ condition1: index - 1 }, 'removeAt');\n      const removalTarget = { ...nodeBeforeTarget.next };\n      nodeBeforeTarget.next = nodeBeforeTarget.next.next;\n      if (index === size - 1) {\n        tail = nodeBeforeTarget;\n        console.log('NEW tail:', tail);\n      }\n      size -= 1;\n      return removalTarget;\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  function isIndexValid(targetIndex) {\n    if (targetIndex + 1 > size) {\n      throw new Error('Invalid Index');\n    }\n  }\n\n  // MAYBE: use undefined instead of null\n  function node(value = null, next = null) {\n    return { value, next };\n  }\n\n  return {\n    append,\n    prepend,\n    getHead,\n    getSize,\n    getTail,\n    at,\n    pop,\n    contains,\n    find,\n    toString,\n    insertAt,\n    removeAt,\n    node,\n  };\n}\n\n// const aList = linkedList();\n// aList.append(2);\n// aList.append(5);\n// aList.append(4);\n// aList.prepend(10);\n// aList.prepend(7);\n// aList.prepend(8);\n\n// const at = aList.at(4);\n\n// const contains = aList.contains(8);\n// const find = aList.find(1000);\n\n// const toString = aList.toString();\n// console.log('toString:', toString);\n\n// const [head, tail, size] = [aList.getHead(), aList.getTail(), aList.getSize()];\n// console.log('head:', head);\n// console.log('tail:', tail);\n// console.log('size:', size);\n\nexport { testFunc, linkedList };\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","testFunc","console","log","linkedList","head","tail","size","getTail","getSize","checkIfSizeIs1","newNodeReference","traverse","conditionObject","mode","arguments","length","undefined","currentNode","currentIndex","resultString","stopConditionMet","currentValue","condition1","condition2","meetsCondition","evaluateCondition","value","concat","next","append","node","prepend","isIndexValid","targetIndex","Error","getHead","at","pop","last","secondToLast","error","contains","find","index","Number","isInteger","toString","insertAt","insertionPoint","newNode","removeAt","aList","nodeBeforeTarget","removalTarget"],"sourceRoot":""}