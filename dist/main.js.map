{"version":3,"file":"main.js","mappings":"mBAIAA,QAAQC,IAAI,uC","sources":["webpack://@thereisnodeveloper/linked-list-js/./src/index.js"],"sourcesContent":["// #region required-template\n// import './reset.css';\n// import './style.css';\n\nconsole.log('Linked List package loaded - test!!!');\n// eslint-disable-next-line no-unused-vars\n// const testElement = document.createElement('div');\n// #endregion\n\n// use Factory functions instead of clsasses\nexport function testFunc() {\n  console.log('test function......');\n}\n\nexport function linkedList() {\n  // export default function linkedList() {\n  let head;\n  let tail;\n  let size = 0;\n\n  function getTail() {\n    // MAYBE: I could traverse instead of storing tail in memory\n    return tail;\n  }\n\n  function getSize() {\n    return size;\n  }\n\n  function getHead() {\n    return head;\n  }\n\n  function checkIfSizeIs1(newNodeReference) {\n    if (getSize() === 0) {\n      head = newNodeReference;\n      tail = newNodeReference;\n      return true;\n    }\n    return false;\n  }\n\n  function traverse(\n    conditionObject,\n    mode = null,\n    currentNode = head,\n    currentIndex = 0,\n    resultString = ''\n  ) {\n    // TODO: calculate big O for time & space\n    // MAYBE: use loop instead\n\n    let stopConditionMet = false;\n    const currentValue = currentNode.value;\n\n    stopConditionMet = evaluateCondition(conditionObject, mode, currentIndex, currentValue);\n\n    // BASE CASE\n    if (stopConditionMet === true) {\n      if (mode === 'find') {\n        return currentIndex;\n      }\n      if (mode === 'toString') {\n        return `${resultString}( ${currentNode.value} ) -> ` + ' null';\n        // return resultString  + ' null';\n      }\n      return currentNode;\n    }\n    if (currentNode === tail) return currentNode;\n\n    // RECURSIVE CASE\n\n    resultString = resultString.concat(`( ${currentNode.value} )`, '->');\n    currentNode = currentNode.next;\n\n    return traverse(conditionObject, mode, currentNode, currentIndex + 1, resultString);\n  }\n\n  function evaluateCondition(conditionObject, mode, currentIndex, currentValue) {\n    // MAYBE: instead of using mode, assign \"this\" to static variable (which poiints to the caller function)\n    let { condition1, condition2 } = conditionObject;\n    let meetsCondition = false;\n    switch (mode) {\n      case 'at':\n      case 'pop':\n      case 'toString':\n      case 'insertAt':\n      case 'removeAt': {\n        condition2 = currentIndex;\n        break;\n      }\n      case 'contains':\n      case 'find': {\n        condition2 = currentValue;\n        break;\n      }\n\n      default:\n    }\n    meetsCondition = condition1 === condition2;\n\n    return meetsCondition;\n  }\n\n  function at(targetIndex) {\n    try {\n      isIndexValid(targetIndex);\n      const result = traverse({ condition1: targetIndex }, 'at');\n      return result;\n    } catch (error) {\n      console.error(error);\n    }\n  }\n  function pop() {\n    try {\n      if (size <= 0) throw new Error('Cannot pop, size is 0');\n      const last = { ...tail };\n\n      tail.value = null;\n      const secondToLast = traverse({ condition1: size - 2 }, 'pop'); // find 2nd to the last element\n      secondToLast.next = null;\n      // set new tail value\n      tail = secondToLast;\n      size -= 1;\n\n      return last;\n    } catch (error) {\n      console.error(error);\n    }\n  }\n  function contains(value) {\n    const currentNode = traverse({ condition1: value }, 'contains');\n\n    return currentNode.value === value;\n  }\n\n  function find(value) {\n    const index = traverse({ condition1: value }, 'find');\n    return Number.isInteger(index) ? index : undefined; // traverse will return currentNode (tail) if nothing is found. If found, it will return an index,\n  }\n\n  function toString() {\n    return traverse({ condition1: size - 1 }, 'toString');\n  }\n  function append(value) {\n    const newNodeReference = node(value);\n\n    checkIfSizeIs1(newNodeReference);\n\n    getTail().next = newNodeReference;\n\n    tail = newNodeReference;\n    size++;\n\n    return newNodeReference;\n  }\n\n  function prepend(value) {\n    const newNodeReference = node(value, head);\n\n    checkIfSizeIs1(newNodeReference);\n\n    head = newNodeReference;\n    size++;\n    return newNodeReference;\n  }\n\n  function insertAt(value, index) {\n    try {\n      isIndexValid(index);\n\n      if (index === 0) {\n        prepend(value);\n        return;\n      }\n      if (index === size - 1) {\n        append(value);\n        return;\n      }\n\n      const insertionPoint = traverse({ condition1: index }, 'insertAt');\n      const newNode = node(value, insertionPoint.next);\n      insertionPoint.next = newNode;\n      size += 1;\n      return newNode;\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  function removeAt(index) {\n    try {\n      isIndexValid(index);\n      if (index === 0) {\n        aList.pop;\n        return;\n      }\n\n      const nodeBeforeTarget = traverse({ condition1: index - 1 }, 'removeAt');\n      const removalTarget = { ...nodeBeforeTarget.next };\n      nodeBeforeTarget.next = nodeBeforeTarget.next.next;\n      if (index === size - 1) {\n        tail = nodeBeforeTarget;\n        console.log('NEW tail:', tail);\n      }\n      size -= 1;\n      return removalTarget;\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  function isIndexValid(targetIndex) {\n    if (targetIndex + 1 > size) {\n      throw new Error('Invalid Index');\n    }\n  }\n\n  // MAYBE: use undefined instead of null\n  function node(value = null, next = null) {\n    return { value, next };\n  }\n\n  return {\n    append,\n    prepend,\n    getHead,\n    getSize,\n    getTail,\n    at,\n    pop,\n    contains,\n    find,\n    toString,\n    insertAt,\n    removeAt,\n    node,\n  };\n}\n\n// const aList = linkedList();\n// aList.append(2);\n// aList.append(5);\n// aList.append(4);\n// aList.prepend(10);\n// aList.prepend(7);\n// aList.prepend(8);\n\n// const at = aList.at(4);\n\n// const contains = aList.contains(8);\n// const find = aList.find(1000);\n\n// const toString = aList.toString();\n// console.log('toString:', toString);\n\n// const [head, tail, size] = [aList.getHead(), aList.getTail(), aList.getSize()];\n// console.log('head:', head);\n// console.log('tail:', tail);\n// console.log('size:', size);\n"],"names":["console","log"],"sourceRoot":""}